import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

describe('transformApiClient', () => {
  const testDir = path.join(__dirname, 'test-fixtures');
  const inputFile = path.join(testDir, 'input.ts');
  const outputFile = path.join(testDir, 'output.ts');
  
  beforeEach(() => {
    // Create test directory if it doesn't exist
    if (!fs.existsSync(testDir)) {
      fs.mkdirSync(testDir, { recursive: true });
    }
  });

  afterEach(() => {
    // Clean up test files
    [inputFile, outputFile].forEach(file => {
      if (fs.existsSync(file)) {
        fs.unlinkSync(file);
      }
    });
  });

  const applyTransformation = (content: string): string => {
    // Apply the same transformation logic from the main function
    if (!content.includes('import { type Prettify }')) {
      content = content.replace(
        '// ReSharper disable InconsistentNaming',
        'import { type Prettify } from "../../utils";\n\n// ReSharper disable InconsistentNaming'
      );
    }

    const methodRegex = /(\w+)\s*\(\s*([^)]+)\s*\)\s*:\s*(Promise<[^>]+>)\s*\{/g;
    const interfaces: string[] = [];
    const interfaceNames: Set<string> = new Set(); // Track interface names to avoid duplicates
    const methodReplacements: Array<{ original: string; replacement: string }> = [];

    let match;
    while ((match = methodRegex.exec(content)) !== null) {
      const [fullMatch, methodName, params, returnType] = match;
      
      if (methodName === 'constructor' || methodName.startsWith('process')) {
        continue;
      }

      const paramList = params.split(",").map((p) => p.trim());
      const nonAbortSignalParams = paramList.filter(param => {
        const colonIndex = param.indexOf(":");
        if (colonIndex > 0) {
          const paramName = param.substring(0, colonIndex).trim();
          return paramName !== "signal" && paramName !== "abortSignal";
        }
        return true;
      });

      if (!params.trim() || nonAbortSignalParams.length <= 1) {
        continue;
      }

      const paramObjects: string[] = [];
      const paramNames: string[] = [];

      paramList.forEach((param) => {
        const colonIndex = param.indexOf(":");
        if (colonIndex > 0) {
          const rawParamName = param.substring(0, colonIndex).trim();
          const paramType = param.substring(colonIndex + 1).trim();
          // Remove the ? from optional parameters for destructuring
          const paramName = rawParamName.replace('?', '');
          paramObjects.push(`${rawParamName}: ${paramType}`);
          paramNames.push(paramName);
        }
      });

      if (paramObjects.length === 0) {
        continue;
      }

      // Create interface name with return type for uniqueness
      const returnTypeClean = returnType.replace(/Promise<|>/g, '').replace(/[<>]/g, '');
      const capitalizedReturnType = returnTypeClean.charAt(0).toUpperCase() + returnTypeClean.slice(1);
      const interfaceName = `${methodName.charAt(0).toUpperCase() + methodName.slice(1)}${capitalizedReturnType}Params`;
      const paramSignature = paramObjects.join(";\n  ");
      
      // Check if this exact interface already exists
      if (!interfaceNames.has(interfaceName)) {
        interfaceNames.add(interfaceName);
        const interfaceDefinition = `interface ${interfaceName} extends Prettify<{\n  ${paramObjects.join(";\n  ")};\n}> {}`;
        interfaces.push(interfaceDefinition);
      }

      const destructuring = `const { ${paramNames.join(", ")} } = params;`;
      const newMethodSignature = `${methodName}(params: ${interfaceName}): ${returnType} {\n        ${destructuring}`;
      
      methodReplacements.push({
        original: fullMatch,
        replacement: newMethodSignature
      });
    }

    if (interfaces.length > 0) {
      const importEndIndex = content.indexOf('// ReSharper disable InconsistentNaming');
      if (importEndIndex !== -1) {
        const insertPoint = content.indexOf('\n', importEndIndex) + 1;
        const interfaceSection = '\n' + interfaces.join('\n\n') + '\n';
        content = content.slice(0, insertPoint) + interfaceSection + content.slice(insertPoint);
      }
    }

    methodReplacements.forEach(({ original, replacement }) => {
      content = content.replace(original, replacement);
    });

    return content;
  };

  it('should transform methods with multiple non-abortSignal parameters', () => {
    const input = `//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class TestClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    
    constructor(baseUrl?: string) {
        this.baseUrl = baseUrl ?? "";
    }

    createUser(name: string, email: string, signal?: AbortSignal): Promise<User> {
        let url_ = this.baseUrl + "/users";
        return this.http.fetch(url_, {}).then(response => response.json());
    }

    getUser(signal?: AbortSignal): Promise<User> {
        let url_ = this.baseUrl + "/user";
        return this.http.fetch(url_, {}).then(response => response.json());
    }

    updateUser(id: string, data: UserData, signal?: AbortSignal): Promise<User> {
        let url_ = this.baseUrl + "/users/" + id;
        return this.http.fetch(url_, {}).then(response => response.json());
    }
}`;

    const result = applyTransformation(input);
    
    // Check that the Prettify import was added
    expect(result).toContain('import { type Prettify } from "../../utils"');
    
    // Check that interfaces were generated for multi-parameter methods
    expect(result).toContain('interface CreateUserUserParams extends Prettify<{');
    expect(result).toContain('name: string;');
    expect(result).toContain('email: string;');
    expect(result).toContain('signal?: AbortSignal;');
    
    expect(result).toContain('interface UpdateUserUserParams extends Prettify<{');
    expect(result).toContain('id: string;');
    expect(result).toContain('data: UserData;');
    
    // Check that method signatures were transformed
    expect(result).toContain('createUser(params: CreateUserUserParams): Promise<User> {');
    expect(result).toContain('const { name, email, signal } = params;');
    
    expect(result).toContain('updateUser(params: UpdateUserUserParams): Promise<User> {');
    expect(result).toContain('const { id, data, signal } = params;');
    
    // Check that single-parameter methods were NOT transformed
    expect(result).toContain('getUser(signal?: AbortSignal): Promise<User> {');
    expect(result).not.toContain('GetUserParams');
  });

  it('should not transform methods with only abortSignal parameter', () => {
    const input = `//----------------------
// <auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class TestClient {
    getSomething(signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/something";
        return this.http.fetch(url_, {}).then(response => response.json());
    }
}`;

    const result = applyTransformation(input);
    
    // Method should remain unchanged
    expect(result).toContain('getSomething(signal?: AbortSignal): Promise<void> {');
    
    // No interfaces should be generated
    expect(result).not.toContain('GetSomethingParams');
  });

  it('should not transform constructors', () => {
    const input = `//----------------------
// <auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class TestClient {
    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ?? "";
        this.http = http ?? window;
    }
}`;

    const result = applyTransformation(input);
    
    // Constructor should remain unchanged
    expect(result).toContain('constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {');
    
    // No interfaces should be generated for constructors
    expect(result).not.toContain('ConstructorParams');
  });

  it('should handle methods with no parameters', () => {
    const input = `//----------------------
// <auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class TestClient {
    getAll(): Promise<User[]> {
        let url_ = this.baseUrl + "/users";
        return this.http.fetch(url_, {}).then(response => response.json());
    }
}`;

    const result = applyTransformation(input);
    
    // Method should remain unchanged since it has no parameters
    expect(result).toContain('getAll(): Promise<User[]> {');
    
    // No interfaces should be generated
    expect(result).not.toContain('GetAllParams');
  });

  it('should handle complex parameter types correctly', () => {
    const input = `//----------------------
// <auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class TestClient {
    complexMethod(data: { name: string; age: number }, options: RequestOptions, signal?: AbortSignal): Promise<Response> {
        let url_ = this.baseUrl + "/complex";
        return this.http.fetch(url_, {}).then(response => response.json());
    }
}`;

    const result = applyTransformation(input);
    
    // Check that complex types are preserved
    expect(result).toContain('interface ComplexMethodResponseParams extends Prettify<{');
    expect(result).toContain('data: { name: string; age: number };');
    expect(result).toContain('options: RequestOptions;');
    expect(result).toContain('signal?: AbortSignal;');
    
    // Check that method signature was transformed
    expect(result).toContain('complexMethod(params: ComplexMethodResponseParams): Promise<Response> {');
    expect(result).toContain('const { data, options, signal } = params;');
  });

  it('should handle methods with only one non-signal parameter correctly', () => {
    const input = `//----------------------
// <auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class TestClient {
    deleteUser(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/users/" + id;
        return this.http.fetch(url_, {}).then(response => response.json());
    }
}`;

    const result = applyTransformation(input);
    
    // Method should be transformed even with one non-signal parameter when signal is also present
    expect(result).toContain('deleteUser(params: DeleteUserVoidParams): Promise<void> {');
    expect(result).toContain('const { id, signal } = params;');
    
    // Interface should be generated
    expect(result).toContain('interface DeleteUserVoidParams extends Prettify<{');
    expect(result).toContain('id: string;');
    expect(result).toContain('signal?: AbortSignal;');
  });

  it('should preserve method body content after destructuring', () => {
    const input = `//----------------------
// <auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class TestClient {
    createUser(name: string, email: string, signal?: AbortSignal): Promise<User> {
        let url_ = this.baseUrl + "/users";
        url_ = url_.replace(/[?&]$/, "");
        
        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify({ name, email })
        };
        
        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateUser(_response);
        });
    }
}`;

    const result = applyTransformation(input);
    
    // Check that method body is preserved after destructuring
    expect(result).toContain('const { name, email, signal } = params;');
    expect(result).toContain('let url_ = this.baseUrl + "/users";');
    expect(result).toContain('url_ = url_.replace(/[?&]$/, "");');
    expect(result).toContain('body: JSON.stringify({ name, email })');
    expect(result).toContain('return this.processCreateUser(_response);');
  });

  it('should generate unique interface names for methods with same name but different return types', () => {
    const input = `//----------------------
// <auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class LoopClient {
    sendLoopNotification(accessToken: string, signal?: AbortSignal): Promise<LoopNotificationResponse> {
        let url_ = this.baseUrl + "/loop/notification";
        return this.http.fetch(url_, {}).then(response => response.json());
    }
}

export class NotificationsClient {
    sendLoopNotification(accessToken: string, signal?: AbortSignal): Promise<NotificationV2Response> {
        let url_ = this.baseUrl + "/notifications/loop";
        return this.http.fetch(url_, {}).then(response => response.json());
    }
}`;

    const result = applyTransformation(input);
    
    // Should generate unique interface names based on return type
    expect(result).toContain('interface SendLoopNotificationLoopNotificationResponseParams');
    expect(result).toContain('interface SendLoopNotificationNotificationV2ResponseParams');
    
    // Should not have duplicate interface names
    const allInterfaces = result.match(/interface \w+Params/g) || [];
    const uniqueInterfaces = new Set(allInterfaces);
    expect(allInterfaces.length).toBe(uniqueInterfaces.size);
  });

  it('should not include question mark in destructuring for optional parameters', () => {
    const input = `//----------------------
// <auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class TestClient {
    testMethod(accessToken: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/test";
        return this.http.fetch(url_, {}).then(response => response.json());
    }
}`;

    const result = applyTransformation(input);
    
    // Should not have signal? in destructuring
    expect(result).not.toContain('signal? }');
    expect(result).toContain('const { accessToken, signal } = params;');
  });
});